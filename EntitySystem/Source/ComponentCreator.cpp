/*
	This file is automatically generated.
	Do not edit this file manually.
*/

#include "../Include/ComponentDataConversion.hpp"
#include "../Include/EntitySystem.hpp"
#include "../Include/SystemNodes.hpp"
#include "../Include/Components.hpp"
#include "../Include/Entity.hpp"
#include "../Include/ComponentMaps.hpp"
#include "../Include/EntitySystem.hpp"
#include "../Include/EntityContainer.hpp"
#include "../Include/SystemNodes.hpp"
#include "../Include/SystemNodesContainer.hpp"

#include <algorithm>

using namespace Fnd::EntitySystem;

template <typename ComponentType>
Component* CreateComponentInternal( const Fnd::GameComponentInterfaces::WorldData::Entity::Component& component_data, EntitySystem& entity_system );

template <>
Component* CreateComponentInternal<SceneNodeComponent>( const Fnd::GameComponentInterfaces::WorldData::Entity::Component& component_data, EntitySystem& entity_system )
{
	SceneNodeComponent tempcomponent;
	bool success = true;
	do
	{
		auto data = component_data.data.find("parent_name");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<string64>( "", tempcomponent.data.parent_name );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<string64>( as_string, tempcomponent.data.parent_name );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("parent_id");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<uint32>( "4294967295", tempcomponent.data.parent_id );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<uint32>( as_string, tempcomponent.data.parent_id );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("position");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<Fnd::Math::Vector3>( as_string, tempcomponent.data.position );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("rotation");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<Fnd::Math::Quaternion>( as_string, tempcomponent.data.rotation );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("scale");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<Fnd::Math::Vector3>( "(1,1,1)", tempcomponent.data.scale );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<Fnd::Math::Vector3>( as_string, tempcomponent.data.scale );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("transform");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<Fnd::Math::Matrix4>( "(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1)", tempcomponent.data.transform );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<Fnd::Math::Matrix4>( as_string, tempcomponent.data.transform );
	}
	while(false);

	if ( success )
	{
		return entity_system.GetComponentMaps().AddComponent<SceneNodeComponent>(tempcomponent);
	}
	else
	{
		return nullptr;
	}
}

template <>
Component* CreateComponentInternal<CameraPropertiesComponent>( const Fnd::GameComponentInterfaces::WorldData::Entity::Component& component_data, EntitySystem& entity_system )
{
	CameraPropertiesComponent tempcomponent;
	bool success = true;
	do
	{
		auto data = component_data.data.find("camera_id");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<uint32>( "0", tempcomponent.data.camera_id );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<uint32>( as_string, tempcomponent.data.camera_id );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("camera_type");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<uint32>( "0", tempcomponent.data.camera_type );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<uint32>( as_string, tempcomponent.data.camera_type );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("viewport_x");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<sint32>( "0", tempcomponent.data.viewport_x );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<sint32>( as_string, tempcomponent.data.viewport_x );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("viewport_y");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<sint32>( "0", tempcomponent.data.viewport_y );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<sint32>( as_string, tempcomponent.data.viewport_y );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("viewport_w");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<sint32>( "0", tempcomponent.data.viewport_w );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<sint32>( as_string, tempcomponent.data.viewport_w );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("viewport_h");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<sint32>( "0", tempcomponent.data.viewport_h );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<sint32>( as_string, tempcomponent.data.viewport_h );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("near_plane");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<float32>( "0.1", tempcomponent.data.near_plane );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.near_plane );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("far_plane");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<float32>( "10000", tempcomponent.data.far_plane );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.far_plane );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("fov");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<float32>( "60", tempcomponent.data.fov );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.fov );
	}
	while(false);

	if ( success )
	{
		return entity_system.GetComponentMaps().AddComponent<CameraPropertiesComponent>(tempcomponent);
	}
	else
	{
		return nullptr;
	}
}

template <>
Component* CreateComponentInternal<ModelComponent>( const Fnd::GameComponentInterfaces::WorldData::Entity::Component& component_data, EntitySystem& entity_system )
{
	ModelComponent tempcomponent;
	bool success = true;
	do
	{
		auto data = component_data.data.find("model_asset_name");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<string512>( as_string, tempcomponent.data.model_asset_name );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("model_id");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<uint32>( "4294967295", tempcomponent.data.model_id );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<uint32>( as_string, tempcomponent.data.model_id );
	}
	while(false);

	if ( success )
	{
		return entity_system.GetComponentMaps().AddComponent<ModelComponent>(tempcomponent);
	}
	else
	{
		return nullptr;
	}
}

template <>
Component* CreateComponentInternal<RigidBodyComponent>( const Fnd::GameComponentInterfaces::WorldData::Entity::Component& component_data, EntitySystem& entity_system )
{
	RigidBodyComponent tempcomponent;
	bool success = true;
	do
	{
		auto data = component_data.data.find("collider_type");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<uint32>( as_string, tempcomponent.data.collider_type );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("is_static");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<bool>( "false", tempcomponent.data.is_static );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<bool>( as_string, tempcomponent.data.is_static );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("is_kinematic");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<bool>( "false", tempcomponent.data.is_kinematic );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<bool>( as_string, tempcomponent.data.is_kinematic );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("uses_gravity");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<bool>( "true", tempcomponent.data.uses_gravity );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<bool>( as_string, tempcomponent.data.uses_gravity );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("can_collide");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<bool>( "true", tempcomponent.data.can_collide );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<bool>( as_string, tempcomponent.data.can_collide );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("mass");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<float32>( "1", tempcomponent.data.mass );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.mass );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("friction");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<float32>( "0.5", tempcomponent.data.friction );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.friction );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("restitution");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<float32>( "0.5", tempcomponent.data.restitution );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.restitution );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("velocity");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<Fnd::Math::Vector3>( "(0,0,0)", tempcomponent.data.velocity );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<Fnd::Math::Vector3>( as_string, tempcomponent.data.velocity );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("angular_velocity");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<Fnd::Math::Vector3>( "(0,0,0)", tempcomponent.data.angular_velocity );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<Fnd::Math::Vector3>( as_string, tempcomponent.data.angular_velocity );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("linear_impulse");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<Fnd::Math::Vector3>( "(0,0,0)", tempcomponent.data.linear_impulse );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<Fnd::Math::Vector3>( as_string, tempcomponent.data.linear_impulse );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("angular_impulse");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<Fnd::Math::Vector3>( "(0,0,0)", tempcomponent.data.angular_impulse );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<Fnd::Math::Vector3>( as_string, tempcomponent.data.angular_impulse );
	}
	while(false);

	if ( success )
	{
		return entity_system.GetComponentMaps().AddComponent<RigidBodyComponent>(tempcomponent);
	}
	else
	{
		return nullptr;
	}
}

template <>
Component* CreateComponentInternal<AmbientLightComponent>( const Fnd::GameComponentInterfaces::WorldData::Entity::Component& component_data, EntitySystem& entity_system )
{
	AmbientLightComponent tempcomponent;
	bool success = true;
	do
	{
		auto data = component_data.data.find("colour");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<Fnd::Math::Vector3>( as_string, tempcomponent.data.colour );
	}
	while(false);

	if ( success )
	{
		return entity_system.GetComponentMaps().AddComponent<AmbientLightComponent>(tempcomponent);
	}
	else
	{
		return nullptr;
	}
}

template <>
Component* CreateComponentInternal<PointLightComponent>( const Fnd::GameComponentInterfaces::WorldData::Entity::Component& component_data, EntitySystem& entity_system )
{
	PointLightComponent tempcomponent;
	bool success = true;
	do
	{
		auto data = component_data.data.find("colour");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<Fnd::Math::Vector3>( as_string, tempcomponent.data.colour );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("range");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.range );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("distance_falloff_start");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<float32>( "0", tempcomponent.data.distance_falloff_start );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.distance_falloff_start );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("distance_falloff_params");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<Fnd::Math::Vector4>( "(1,1,0,0)", tempcomponent.data.distance_falloff_params );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<Fnd::Math::Vector4>( as_string, tempcomponent.data.distance_falloff_params );
	}
	while(false);

	if ( success )
	{
		return entity_system.GetComponentMaps().AddComponent<PointLightComponent>(tempcomponent);
	}
	else
	{
		return nullptr;
	}
}

template <>
Component* CreateComponentInternal<DirectionalLightComponent>( const Fnd::GameComponentInterfaces::WorldData::Entity::Component& component_data, EntitySystem& entity_system )
{
	DirectionalLightComponent tempcomponent;
	bool success = true;
	do
	{
		auto data = component_data.data.find("colour");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<Fnd::Math::Vector3>( as_string, tempcomponent.data.colour );
	}
	while(false);

	if ( success )
	{
		return entity_system.GetComponentMaps().AddComponent<DirectionalLightComponent>(tempcomponent);
	}
	else
	{
		return nullptr;
	}
}

template <>
Component* CreateComponentInternal<SpotLightComponent>( const Fnd::GameComponentInterfaces::WorldData::Entity::Component& component_data, EntitySystem& entity_system )
{
	SpotLightComponent tempcomponent;
	bool success = true;
	do
	{
		auto data = component_data.data.find("colour");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<Fnd::Math::Vector3>( as_string, tempcomponent.data.colour );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("range");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.range );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("near_plane");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<float32>( "0.01", tempcomponent.data.near_plane );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.near_plane );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("fov");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.fov );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("distance_falloff_start");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<float32>( "0", tempcomponent.data.distance_falloff_start );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.distance_falloff_start );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("angular_falloff_start");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<float32>( "0", tempcomponent.data.angular_falloff_start );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.angular_falloff_start );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("distance_falloff_params");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<Fnd::Math::Vector4>( "(1,1,0,0)", tempcomponent.data.distance_falloff_params );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<Fnd::Math::Vector4>( as_string, tempcomponent.data.distance_falloff_params );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("angular_falloff_params");
		if ( data == component_data.data.end() )
		{
			ConvertFromString<Fnd::Math::Vector4>( "(1,1,0,0)", tempcomponent.data.angular_falloff_params );
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<Fnd::Math::Vector4>( as_string, tempcomponent.data.angular_falloff_params );
	}
	while(false);

	if ( success )
	{
		return entity_system.GetComponentMaps().AddComponent<SpotLightComponent>(tempcomponent);
	}
	else
	{
		return nullptr;
	}
}

Component* Fnd::EntitySystem::ComponentMaps::CreateComponent( const Fnd::GameComponentInterfaces::WorldData::Entity::Component& component_data, EntitySystem& entity_system, unsigned int& component_id )
{
	if ( component_data.name == "SceneNodeComponent" )
	{
		component_id = SCENENODECOMPONENT_ID;
		return CreateComponentInternal<SceneNodeComponent>( component_data, entity_system );
	}
	if ( component_data.name == "CameraPropertiesComponent" )
	{
		component_id = CAMERAPROPERTIESCOMPONENT_ID;
		return CreateComponentInternal<CameraPropertiesComponent>( component_data, entity_system );
	}
	if ( component_data.name == "ModelComponent" )
	{
		component_id = MODELCOMPONENT_ID;
		return CreateComponentInternal<ModelComponent>( component_data, entity_system );
	}
	if ( component_data.name == "RigidBodyComponent" )
	{
		component_id = RIGIDBODYCOMPONENT_ID;
		return CreateComponentInternal<RigidBodyComponent>( component_data, entity_system );
	}
	if ( component_data.name == "AmbientLightComponent" )
	{
		component_id = AMBIENTLIGHTCOMPONENT_ID;
		return CreateComponentInternal<AmbientLightComponent>( component_data, entity_system );
	}
	if ( component_data.name == "PointLightComponent" )
	{
		component_id = POINTLIGHTCOMPONENT_ID;
		return CreateComponentInternal<PointLightComponent>( component_data, entity_system );
	}
	if ( component_data.name == "DirectionalLightComponent" )
	{
		component_id = DIRECTIONALLIGHTCOMPONENT_ID;
		return CreateComponentInternal<DirectionalLightComponent>( component_data, entity_system );
	}
	if ( component_data.name == "SpotLightComponent" )
	{
		component_id = SPOTLIGHTCOMPONENT_ID;
		return CreateComponentInternal<SpotLightComponent>( component_data, entity_system );
	}
	else
	return nullptr;
}

