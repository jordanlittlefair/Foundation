/*
	This file is automatically generated.
	Do not edit this file manually.
*/

#ifndef _COMPONENTMAPS_HPP_
#define _COMPONENTMAPS_HPP_

#include "Components.hpp"
#include "../../Utility/Include/IdGenerator.hpp"
#include "../../GameComponentInterfaces/Include/IWorld.hpp"

#include <map>

namespace Fnd
{
namespace EntitySystem
{

class EntitySystem;

class ComponentMaps
{
private:
	std::map<unsigned int, SceneNodeComponent> scenenodecomponent;
	std::map<unsigned int, CameraPropertiesComponent> camerapropertiescomponent;
	std::map<unsigned int, ModelComponent> modelcomponent;
	std::map<unsigned int, RigidBodyComponent> rigidbodycomponent;
	std::map<unsigned int, AmbientLightComponent> ambientlightcomponent;
	std::map<unsigned int, PointLightComponent> pointlightcomponent;
	std::map<unsigned int, DirectionalLightComponent> directionallightcomponent;
	std::map<unsigned int, SpotLightComponent> spotlightcomponent;
	Fnd::Utility::IdGenerator _id_generator;

public:

	/**
		Default constructor.
	*/
	ComponentMaps();

	/**
		Get an existing component from its type and index.
		@note Returns null if the component doesn't exist.
		@tparam ComponentType The type of component.
		@param index The index of the component.
		@return Returns a pointer to the requested component.
	*/
	template <typename ComponentType>
	inline ComponentType* GetComponent( unsigned int index );

	/**
		Get an existing component from its type and index.
		@note Returns null if the component doesn't exist.
		@param component_id The id of the component type.
		@param index The index of the component.
		@return Returns a pointer to the requested component.
	*/
	 Component* GetComponent( unsigned int component_id, unsigned int index );

	/**
		Get the map of 'ComponentType' components.
		@tparam ComponentType The type of component to get the map for.
		@return Returns a map of 'ComponentType' components.
	*/
	template <typename ComponentType>
	std::map<unsigned int, ComponentType>& GetComponentMap();

	/**
		Get the map of 'ComponentType' components.
		@tparam ComponentType The type of component to get the map for.
		@return Returns a map of 'ComponentType' components.
	*/
	template <typename ComponentType>
	inline const std::map<unsigned int, ComponentType>& GetComponentMap() const;

	/**
		Add a component to a map.
		@tparam ComponentType The type of component to add.
		@param component The new component with initial data.
		@return Returns the id of the added component.
	*/
	template <typename ComponentType>
	inline ComponentType* AddComponent( const ComponentType& component = ComponentType() );

	/**
		Create a Component from a WorldData::Entity::Component.
		Returns null if the creation failed.
		@param component_node The WorldData::Entity::Component which describes a component.
		@return Returns a pointer to the component if successful.
	*/
	Component* CreateComponent( const Fnd::GameComponentInterfaces::WorldData::Entity::Component& component_data, EntitySystem& entity_system, unsigned int& component_id );

	template <typename ComponentType>
	inline bool RemoveComponent( ComponentType* component );

	bool RemoveComponent( Component* component );

};

}
}

namespace Fnd
{
namespace EntitySystem
{

/*
	GetComponent<> implementations.
*/

template <>
inline SceneNodeComponent* ComponentMaps::GetComponent<SceneNodeComponent>( unsigned int index )
{
	auto iter = scenenodecomponent.find(index);
	return ( iter == scenenodecomponent.end() ) ? nullptr : &((*iter).second);
}
template <>
inline CameraPropertiesComponent* ComponentMaps::GetComponent<CameraPropertiesComponent>( unsigned int index )
{
	auto iter = camerapropertiescomponent.find(index);
	return ( iter == camerapropertiescomponent.end() ) ? nullptr : &((*iter).second);
}
template <>
inline ModelComponent* ComponentMaps::GetComponent<ModelComponent>( unsigned int index )
{
	auto iter = modelcomponent.find(index);
	return ( iter == modelcomponent.end() ) ? nullptr : &((*iter).second);
}
template <>
inline RigidBodyComponent* ComponentMaps::GetComponent<RigidBodyComponent>( unsigned int index )
{
	auto iter = rigidbodycomponent.find(index);
	return ( iter == rigidbodycomponent.end() ) ? nullptr : &((*iter).second);
}
template <>
inline AmbientLightComponent* ComponentMaps::GetComponent<AmbientLightComponent>( unsigned int index )
{
	auto iter = ambientlightcomponent.find(index);
	return ( iter == ambientlightcomponent.end() ) ? nullptr : &((*iter).second);
}
template <>
inline PointLightComponent* ComponentMaps::GetComponent<PointLightComponent>( unsigned int index )
{
	auto iter = pointlightcomponent.find(index);
	return ( iter == pointlightcomponent.end() ) ? nullptr : &((*iter).second);
}
template <>
inline DirectionalLightComponent* ComponentMaps::GetComponent<DirectionalLightComponent>( unsigned int index )
{
	auto iter = directionallightcomponent.find(index);
	return ( iter == directionallightcomponent.end() ) ? nullptr : &((*iter).second);
}
template <>
inline SpotLightComponent* ComponentMaps::GetComponent<SpotLightComponent>( unsigned int index )
{
	auto iter = spotlightcomponent.find(index);
	return ( iter == spotlightcomponent.end() ) ? nullptr : &((*iter).second);
}

/*
	GetComponentMap<> implementations.
*/

template <>
inline std::map<unsigned int,SceneNodeComponent>& ComponentMaps::GetComponentMap<SceneNodeComponent>()
{
	return scenenodecomponent;
}
template <>
inline std::map<unsigned int,CameraPropertiesComponent>& ComponentMaps::GetComponentMap<CameraPropertiesComponent>()
{
	return camerapropertiescomponent;
}
template <>
inline std::map<unsigned int,ModelComponent>& ComponentMaps::GetComponentMap<ModelComponent>()
{
	return modelcomponent;
}
template <>
inline std::map<unsigned int,RigidBodyComponent>& ComponentMaps::GetComponentMap<RigidBodyComponent>()
{
	return rigidbodycomponent;
}
template <>
inline std::map<unsigned int,AmbientLightComponent>& ComponentMaps::GetComponentMap<AmbientLightComponent>()
{
	return ambientlightcomponent;
}
template <>
inline std::map<unsigned int,PointLightComponent>& ComponentMaps::GetComponentMap<PointLightComponent>()
{
	return pointlightcomponent;
}
template <>
inline std::map<unsigned int,DirectionalLightComponent>& ComponentMaps::GetComponentMap<DirectionalLightComponent>()
{
	return directionallightcomponent;
}
template <>
inline std::map<unsigned int,SpotLightComponent>& ComponentMaps::GetComponentMap<SpotLightComponent>()
{
	return spotlightcomponent;
}

/*
	AddComponent<> implementations.
*/

template <>
inline SceneNodeComponent* ComponentMaps::AddComponent<SceneNodeComponent>( const SceneNodeComponent& component)
{
	unsigned int index = _id_generator.GetId();
	scenenodecomponent[index] = component;
	scenenodecomponent[index].SetIndex(index);
	return &scenenodecomponent[index];
}
template <>
inline CameraPropertiesComponent* ComponentMaps::AddComponent<CameraPropertiesComponent>( const CameraPropertiesComponent& component)
{
	unsigned int index = _id_generator.GetId();
	camerapropertiescomponent[index] = component;
	camerapropertiescomponent[index].SetIndex(index);
	return &camerapropertiescomponent[index];
}
template <>
inline ModelComponent* ComponentMaps::AddComponent<ModelComponent>( const ModelComponent& component)
{
	unsigned int index = _id_generator.GetId();
	modelcomponent[index] = component;
	modelcomponent[index].SetIndex(index);
	return &modelcomponent[index];
}
template <>
inline RigidBodyComponent* ComponentMaps::AddComponent<RigidBodyComponent>( const RigidBodyComponent& component)
{
	unsigned int index = _id_generator.GetId();
	rigidbodycomponent[index] = component;
	rigidbodycomponent[index].SetIndex(index);
	return &rigidbodycomponent[index];
}
template <>
inline AmbientLightComponent* ComponentMaps::AddComponent<AmbientLightComponent>( const AmbientLightComponent& component)
{
	unsigned int index = _id_generator.GetId();
	ambientlightcomponent[index] = component;
	ambientlightcomponent[index].SetIndex(index);
	return &ambientlightcomponent[index];
}
template <>
inline PointLightComponent* ComponentMaps::AddComponent<PointLightComponent>( const PointLightComponent& component)
{
	unsigned int index = _id_generator.GetId();
	pointlightcomponent[index] = component;
	pointlightcomponent[index].SetIndex(index);
	return &pointlightcomponent[index];
}
template <>
inline DirectionalLightComponent* ComponentMaps::AddComponent<DirectionalLightComponent>( const DirectionalLightComponent& component)
{
	unsigned int index = _id_generator.GetId();
	directionallightcomponent[index] = component;
	directionallightcomponent[index].SetIndex(index);
	return &directionallightcomponent[index];
}
template <>
inline SpotLightComponent* ComponentMaps::AddComponent<SpotLightComponent>( const SpotLightComponent& component)
{
	unsigned int index = _id_generator.GetId();
	spotlightcomponent[index] = component;
	spotlightcomponent[index].SetIndex(index);
	return &spotlightcomponent[index];
}

/*
	RemoveComponent<> implementations.
*/

template <>
inline bool ComponentMaps::RemoveComponent<SceneNodeComponent>( SceneNodeComponent* component )
{
	auto iter = scenenodecomponent.find(component->GetIndex());
	if ( iter != scenenodecomponent.end() )
	{
		scenenodecomponent.erase(iter);
		return true;
	}
	else
	{
		return false;
	}

	return true;
}
template <>
inline bool ComponentMaps::RemoveComponent<CameraPropertiesComponent>( CameraPropertiesComponent* component )
{
	auto iter = camerapropertiescomponent.find(component->GetIndex());
	if ( iter != camerapropertiescomponent.end() )
	{
		camerapropertiescomponent.erase(iter);
		return true;
	}
	else
	{
		return false;
	}

	return true;
}
template <>
inline bool ComponentMaps::RemoveComponent<ModelComponent>( ModelComponent* component )
{
	auto iter = modelcomponent.find(component->GetIndex());
	if ( iter != modelcomponent.end() )
	{
		modelcomponent.erase(iter);
		return true;
	}
	else
	{
		return false;
	}

	return true;
}
template <>
inline bool ComponentMaps::RemoveComponent<RigidBodyComponent>( RigidBodyComponent* component )
{
	auto iter = rigidbodycomponent.find(component->GetIndex());
	if ( iter != rigidbodycomponent.end() )
	{
		rigidbodycomponent.erase(iter);
		return true;
	}
	else
	{
		return false;
	}

	return true;
}
template <>
inline bool ComponentMaps::RemoveComponent<AmbientLightComponent>( AmbientLightComponent* component )
{
	auto iter = ambientlightcomponent.find(component->GetIndex());
	if ( iter != ambientlightcomponent.end() )
	{
		ambientlightcomponent.erase(iter);
		return true;
	}
	else
	{
		return false;
	}

	return true;
}
template <>
inline bool ComponentMaps::RemoveComponent<PointLightComponent>( PointLightComponent* component )
{
	auto iter = pointlightcomponent.find(component->GetIndex());
	if ( iter != pointlightcomponent.end() )
	{
		pointlightcomponent.erase(iter);
		return true;
	}
	else
	{
		return false;
	}

	return true;
}
template <>
inline bool ComponentMaps::RemoveComponent<DirectionalLightComponent>( DirectionalLightComponent* component )
{
	auto iter = directionallightcomponent.find(component->GetIndex());
	if ( iter != directionallightcomponent.end() )
	{
		directionallightcomponent.erase(iter);
		return true;
	}
	else
	{
		return false;
	}

	return true;
}
template <>
inline bool ComponentMaps::RemoveComponent<SpotLightComponent>( SpotLightComponent* component )
{
	auto iter = spotlightcomponent.find(component->GetIndex());
	if ( iter != spotlightcomponent.end() )
	{
		spotlightcomponent.erase(iter);
		return true;
	}
	else
	{
		return false;
	}

	return true;
}

}
}

#endif
