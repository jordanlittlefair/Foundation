/*
	This file is automatically generated.
	Do not edit this file manually.
*/

#include "../Include/ComponentDataConversion.hpp"
#include "../Include/EntitySystem.hpp"

#include <algorithm>

using namespace Fnd::EntitySystem;

template <typename ComponentType>
ComponentId CreateComponentInternal( const Fnd::GameComponentInterfaces::WorldData::Entity::Component& component_data, EntitySystem& entity_system );

template <>
ComponentId CreateComponentInternal<SceneNodeComponent>( const Fnd::GameComponentInterfaces::WorldData::Entity::Component& component_data, EntitySystem& entity_system )
{
	SceneNodeComponent tempcomponent;
	bool success = true;
	do
	{
		auto data = component_data.data.find("parent_name");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<string64>( as_string, tempcomponent.data.parent_name );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("parent_id");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<uint32>( as_string, tempcomponent.data.parent_id );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("position");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<Fnd::Math::Vector3>( as_string, tempcomponent.data.position );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("rotation");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<Fnd::Math::Quaternion>( as_string, tempcomponent.data.rotation );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("scale");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<Fnd::Math::Vector3>( as_string, tempcomponent.data.scale );
	}
	while(false);

	if ( success )
	{
		return entity_system.AddComponent<SceneNodeComponent>(tempcomponent);
	}
	else
	{
		return InvalidComponent;
	}
}

template <>
ComponentId CreateComponentInternal<CameraPropertiesComponent>( const Fnd::GameComponentInterfaces::WorldData::Entity::Component& component_data, EntitySystem& entity_system )
{
	CameraPropertiesComponent tempcomponent;
	bool success = true;
	do
	{
		auto data = component_data.data.find("near_plane");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.near_plane );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("far_plane");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.far_plane );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("fov");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.fov );
	}
	while(false);

	if ( success )
	{
		return entity_system.AddComponent<CameraPropertiesComponent>(tempcomponent);
	}
	else
	{
		return InvalidComponent;
	}
}

template <>
ComponentId CreateComponentInternal<RumbleComponent>( const Fnd::GameComponentInterfaces::WorldData::Entity::Component& component_data, EntitySystem& entity_system )
{
	RumbleComponent tempcomponent;
	bool success = true;
	do
	{
		auto data = component_data.data.find("controller_0");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<bool>( as_string, tempcomponent.data.controller_0 );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("controller_1");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<bool>( as_string, tempcomponent.data.controller_1 );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("controller_2");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<bool>( as_string, tempcomponent.data.controller_2 );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("controller_3");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<bool>( as_string, tempcomponent.data.controller_3 );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("all_controllers");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<bool>( as_string, tempcomponent.data.all_controllers );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("lf_intensity");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.lf_intensity );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("rf_intensity");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.rf_intensity );
	}
	while(false);

	if ( success )
	{
		return entity_system.AddComponent<RumbleComponent>(tempcomponent);
	}
	else
	{
		return InvalidComponent;
	}
}

template <>
ComponentId CreateComponentInternal<RigidBodyComponent>( const Fnd::GameComponentInterfaces::WorldData::Entity::Component& component_data, EntitySystem& entity_system )
{
	RigidBodyComponent tempcomponent;
	bool success = true;
	do
	{
		auto data = component_data.data.find("collider_type");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<uint32>( as_string, tempcomponent.data.collider_type );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("is_static");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<bool>( as_string, tempcomponent.data.is_static );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("mass");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.mass );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("friction");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.friction );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("restitution");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.restitution );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("velocity");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<Fnd::Math::Vector3>( as_string, tempcomponent.data.velocity );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("angular_velocity");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<Fnd::Math::Vector3>( as_string, tempcomponent.data.angular_velocity );
	}
	while(false);

	if ( success )
	{
		return entity_system.AddComponent<RigidBodyComponent>(tempcomponent);
	}
	else
	{
		return InvalidComponent;
	}
}

template <>
ComponentId CreateComponentInternal<AmbientLightComponent>( const Fnd::GameComponentInterfaces::WorldData::Entity::Component& component_data, EntitySystem& entity_system )
{
	AmbientLightComponent tempcomponent;
	bool success = true;
	do
	{
		auto data = component_data.data.find("colour");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<Fnd::Math::Vector3>( as_string, tempcomponent.data.colour );
	}
	while(false);

	if ( success )
	{
		return entity_system.AddComponent<AmbientLightComponent>(tempcomponent);
	}
	else
	{
		return InvalidComponent;
	}
}

template <>
ComponentId CreateComponentInternal<DirectionalLightComponent>( const Fnd::GameComponentInterfaces::WorldData::Entity::Component& component_data, EntitySystem& entity_system )
{
	DirectionalLightComponent tempcomponent;
	bool success = true;
	do
	{
		auto data = component_data.data.find("colour");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<Fnd::Math::Vector3>( as_string, tempcomponent.data.colour );
	}
	while(false);

	if ( success )
	{
		return entity_system.AddComponent<DirectionalLightComponent>(tempcomponent);
	}
	else
	{
		return InvalidComponent;
	}
}

template <>
ComponentId CreateComponentInternal<SpotLightComponent>( const Fnd::GameComponentInterfaces::WorldData::Entity::Component& component_data, EntitySystem& entity_system )
{
	SpotLightComponent tempcomponent;
	bool success = true;
	do
	{
		auto data = component_data.data.find("colour");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<Fnd::Math::Vector3>( as_string, tempcomponent.data.colour );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("range");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.range );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("near_plane");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.near_plane );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("fov");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.fov );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("distance_falloff_start");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.distance_falloff_start );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("angular_falloff_start");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.angular_falloff_start );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("distance_falloff_params");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<Fnd::Math::Vector4>( as_string, tempcomponent.data.distance_falloff_params );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("angular_falloff_params");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<Fnd::Math::Vector4>( as_string, tempcomponent.data.angular_falloff_params );
	}
	while(false);

	if ( success )
	{
		return entity_system.AddComponent<SpotLightComponent>(tempcomponent);
	}
	else
	{
		return InvalidComponent;
	}
}

template <>
ComponentId CreateComponentInternal<PointLightComponent>( const Fnd::GameComponentInterfaces::WorldData::Entity::Component& component_data, EntitySystem& entity_system )
{
	PointLightComponent tempcomponent;
	bool success = true;
	do
	{
		auto data = component_data.data.find("colour");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<Fnd::Math::Vector3>( as_string, tempcomponent.data.colour );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("range");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.range );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("distance_falloff_start");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.distance_falloff_start );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("distance_falloff_params");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<Fnd::Math::Vector4>( as_string, tempcomponent.data.distance_falloff_params );
	}
	while(false);

	if ( success )
	{
		return entity_system.AddComponent<PointLightComponent>(tempcomponent);
	}
	else
	{
		return InvalidComponent;
	}
}

template <>
ComponentId CreateComponentInternal<ModelComponent>( const Fnd::GameComponentInterfaces::WorldData::Entity::Component& component_data, EntitySystem& entity_system )
{
	ModelComponent tempcomponent;
	bool success = true;
	do
	{
		auto data = component_data.data.find("model_asset_name");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<string512>( as_string, tempcomponent.data.model_asset_name );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("model_id");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<uint32>( as_string, tempcomponent.data.model_id );
	}
	while(false);

	if ( success )
	{
		return entity_system.AddComponent<ModelComponent>(tempcomponent);
	}
	else
	{
		return InvalidComponent;
	}
}

template <>
ComponentId CreateComponentInternal<SkyBoxComponent>( const Fnd::GameComponentInterfaces::WorldData::Entity::Component& component_data, EntitySystem& entity_system )
{
	SkyBoxComponent tempcomponent;
	bool success = true;
	do
	{
		auto data = component_data.data.find("sky_colour");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<Fnd::Math::Vector3>( as_string, tempcomponent.data.sky_colour );
	}
	while(false);

	if ( success )
	{
		return entity_system.AddComponent<SkyBoxComponent>(tempcomponent);
	}
	else
	{
		return InvalidComponent;
	}
}

template <>
ComponentId CreateComponentInternal<MotionBlurComponent>( const Fnd::GameComponentInterfaces::WorldData::Entity::Component& component_data, EntitySystem& entity_system )
{
	MotionBlurComponent tempcomponent;
	bool success = true;
	do
	{
		auto data = component_data.data.find("target_fps");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.target_fps );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("motion_blur_scale");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.motion_blur_scale );
	}
	while(false);

	if ( success )
	{
		return entity_system.AddComponent<MotionBlurComponent>(tempcomponent);
	}
	else
	{
		return InvalidComponent;
	}
}

template <>
ComponentId CreateComponentInternal<BloomComponent>( const Fnd::GameComponentInterfaces::WorldData::Entity::Component& component_data, EntitySystem& entity_system )
{
	BloomComponent tempcomponent;
	bool success = true;
	do
	{
		auto data = component_data.data.find("bloom_threshold");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.bloom_threshold );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("bloom_blur_radius");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.bloom_blur_radius );
	}
	while(false);

	if ( success )
	{
		return entity_system.AddComponent<BloomComponent>(tempcomponent);
	}
	else
	{
		return InvalidComponent;
	}
}

template <>
ComponentId CreateComponentInternal<ToneMapComponent>( const Fnd::GameComponentInterfaces::WorldData::Entity::Component& component_data, EntitySystem& entity_system )
{
	ToneMapComponent tempcomponent;
	bool success = true;
	do
	{
		auto data = component_data.data.find("f_number");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.f_number );
	}
	while(false);

	if ( success )
	{
		return entity_system.AddComponent<ToneMapComponent>(tempcomponent);
	}
	else
	{
		return InvalidComponent;
	}
}

template <>
ComponentId CreateComponentInternal<AmbientOcclusionComponent>( const Fnd::GameComponentInterfaces::WorldData::Entity::Component& component_data, EntitySystem& entity_system )
{
	AmbientOcclusionComponent tempcomponent;
	bool success = true;
	do
	{
		auto data = component_data.data.find("ssao_radius");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.ssao_radius );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("ssao_exponent");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.ssao_exponent );
	}
	while(false);

	do
	{
		auto data = component_data.data.find("ssao_blur_radius");
		if ( data == component_data.data.end() )
		{
			success = false;
			break;
		}

		const char* as_string = data->second.value.c_str();

		ConvertFromString<float32>( as_string, tempcomponent.data.ssao_blur_radius );
	}
	while(false);

	if ( success )
	{
		return entity_system.AddComponent<AmbientOcclusionComponent>(tempcomponent);
	}
	else
	{
		return InvalidComponent;
	}
}

ComponentId Fnd::EntitySystem::EntitySystem::CreateComponent( const Fnd::GameComponentInterfaces::WorldData::Entity::Component& component_data, EntitySystem& entity_system, unsigned int& component_id )
{
	if ( component_data.name == "SceneNodeComponent" )
	{
		component_id = SCENENODECOMPONENT_ID;
		return CreateComponentInternal<SceneNodeComponent>( component_data, entity_system );
	}
	else
	if ( component_data.name == "CameraPropertiesComponent" )
	{
		component_id = CAMERAPROPERTIESCOMPONENT_ID;
		return CreateComponentInternal<CameraPropertiesComponent>( component_data, entity_system );
	}
	else
	if ( component_data.name == "RumbleComponent" )
	{
		component_id = RUMBLECOMPONENT_ID;
		return CreateComponentInternal<RumbleComponent>( component_data, entity_system );
	}
	else
	if ( component_data.name == "RigidBodyComponent" )
	{
		component_id = RIGIDBODYCOMPONENT_ID;
		return CreateComponentInternal<RigidBodyComponent>( component_data, entity_system );
	}
	else
	if ( component_data.name == "AmbientLightComponent" )
	{
		component_id = AMBIENTLIGHTCOMPONENT_ID;
		return CreateComponentInternal<AmbientLightComponent>( component_data, entity_system );
	}
	else
	if ( component_data.name == "DirectionalLightComponent" )
	{
		component_id = DIRECTIONALLIGHTCOMPONENT_ID;
		return CreateComponentInternal<DirectionalLightComponent>( component_data, entity_system );
	}
	else
	if ( component_data.name == "SpotLightComponent" )
	{
		component_id = SPOTLIGHTCOMPONENT_ID;
		return CreateComponentInternal<SpotLightComponent>( component_data, entity_system );
	}
	else
	if ( component_data.name == "PointLightComponent" )
	{
		component_id = POINTLIGHTCOMPONENT_ID;
		return CreateComponentInternal<PointLightComponent>( component_data, entity_system );
	}
	else
	if ( component_data.name == "ModelComponent" )
	{
		component_id = MODELCOMPONENT_ID;
		return CreateComponentInternal<ModelComponent>( component_data, entity_system );
	}
	else
	if ( component_data.name == "SkyBoxComponent" )
	{
		component_id = SKYBOXCOMPONENT_ID;
		return CreateComponentInternal<SkyBoxComponent>( component_data, entity_system );
	}
	else
	if ( component_data.name == "MotionBlurComponent" )
	{
		component_id = MOTIONBLURCOMPONENT_ID;
		return CreateComponentInternal<MotionBlurComponent>( component_data, entity_system );
	}
	else
	if ( component_data.name == "BloomComponent" )
	{
		component_id = BLOOMCOMPONENT_ID;
		return CreateComponentInternal<BloomComponent>( component_data, entity_system );
	}
	else
	if ( component_data.name == "ToneMapComponent" )
	{
		component_id = TONEMAPCOMPONENT_ID;
		return CreateComponentInternal<ToneMapComponent>( component_data, entity_system );
	}
	else
	if ( component_data.name == "AmbientOcclusionComponent" )
	{
		component_id = AMBIENTOCCLUSIONCOMPONENT_ID;
		return CreateComponentInternal<AmbientOcclusionComponent>( component_data, entity_system );
	}
	return InvalidComponent;
}

